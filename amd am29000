amd am29000

2. Kokia buvo elementinė kompiuterio/procesoriaus bazė (relės,
vakuuminės lempos, tranzistoriai, magnetinės šerdys, integriniai
grandynai (IC) – ar jie hibridiniai, mažo integracijos masto, Didelio
integracijos masto (LSI), labai didelio integracijos masto (VLSI), ar
tai buvo monokristaliniai šiuolaikiniai mikroprocesoriai)? Kokios buvo
fizinės įrangos savybės (svoris, dydis, energijos suvartojimas)?

The AMD Am29000, released in may 1988 contained 428,000 transistors on a 1-micron process with a 0.8-micron effective channel length.
source: 
Wikipedia contributors. (2024, May 9). AMD Am29000. In Wikipedia, The Free Encyclopedia. 
Retrieved 22:14, December 18, 2024, from 
https://en.wikipedia.org/w/index.php?title=AMD_Am29000&oldid=1223052875

The weight of the Am29000 chip is minimal.
source: idk look at it

Size :	1.1" x 1.1" / 2.8cm x 2.8cm
Maximum power dissipation : 	2.31 Watt
source: https://www.cpu-world.com/CPUs/29000/AMD-Am29000-20KC.html

3. Kokio tipo architektūrą turėjo abu kompiuteriai? Ar jie buvo
akumuliatoriniai, registriniai, stekiniai (dėklo architektūros),
atmintis-į-atmintį architektūros arba kokios nors kitos architektūros?

The 29k evolved from the same Berkeley RISC design
source: https://en.wikipedia.org/wiki/AMD_Am29000

4. Ar tai buvo beadresinės (stekinės), vieno adreso, dviejų adresų,
trijų adresų ar keturios adresų mašinos?

The AMD AM29000 is Three-address instruction architecture.
source: http://bitsavers.informatik.uni-stuttgart.de/components/amd/Am29000/1987_Am29000_Users_Manual.pdf

5. Kokie buvo registrai abiejose architektūrose? Ar šios architektūros
iš viso turėjo registrus? Ar tai buvo bendrosios paskirties registrai,
ar specializuoti registrai? Kiek registrų turėjo kiekviena
architektūra?  Kokie buvo šių registrų duomenų pločiai? Kokia buvo
specifinė registrų paskirtis?

It was here that the 29000 differed from earlier designs, using a variable window size. 
It also added more registers, including the same 128 registers for the procedure stack, but adding another 64 for global access.
The 29000 also extended the register window stack with an in-memory (and in theory, in-cache) stack. 
When the window filled the calls would be pushed off the end of the register stack into memory, restored as required when the routine returned. 
Generally, the 29000's register usage was considerably more advanced than competing designs based on the Berkeley concepts.

source: wiki

6. Ar požymių bitai buvo naudojami šiose architektūrose? Kokie
požymiai buvo naudojami?

The AMD Am29000 did not implement flags

7. Koks buvo kiekvienos architektūros duomenų plotis (mašininis žodis)?

The AMD Am29000 was a 32-bit architecture, with a machine word size of 32 bits.
wiki

8. Koks buvo kiekvienos sistemos atminties išdėstymas? Ar adresų buvo
erdvė ištisinė, ar ji buvo suskirstytas į segmentus, puslapius,
atminties į bankus? Koks buvo (efektyvus) adreso plotis? Koks buvo
maksimalus įmanomas atminties kiekis kiekvienoje sistemoje? Koks buvo
tipiškas atminties kiekis, su kuria sistema buvo naudojama?

Address Spaces
External instructions and data are contained in one of four, 32-bit address-spaces:
1) InstructionlData Memory.
2) Input/Output.
3) Coprocessor.
4) Instruction Read-Only Memory (Instruction ROM).
An address in the InstructiOn/Data Memory address-space may be treated as virtual or
physical, as determined by the Current Processor Status Register. Address translation for
data accesses is enabled separately from address translation for instruction accesses. A
program in the Supervisor mode may temporarily disable address translation for individual
loads and stores; this permits load-real and store-real operations.
It is possible to partition physical instruction and data addresses into two, separate
physical address-spaces. However, virtual instruction and data addresses appear in the
same virtual address-space (i.e instruction/data memory). 

4 giga-byte virtual address space
source: http://bitsavers.informatik.uni-stuttgart.de/components/amd/Am29000/1987_Am29000_Users_Manual.pdf

9. Ar buvo palaikoma virtualioji atmintis ir kaip? Ar virtuali atmintis
buvo realizuoti, naudojant puslapiavimą, segmentavimą, abu šiuos
mechanizmus?

10. Kokia buvo kiekvienos architektūros komandų sistema (ISA)? Kiek
mašinos komandų turėjo kiekviena architektūra? Kokios buvo instrukcijų
(komandų) klasės?  Kokius instrukcijų formatus palaikė kiekviena
architektūra?  Pateikite 8–16 instrukcijų pavyzdžiai. Kokios komandos
buvo panašios abi architektūros? Kurios komandos skyrėsi?

The Am29000 instruction set contains 115 instructions. These instructions are divided
into 9 classes:
1) Integer Arithmetic-perform integer add, subtract, multiply, and divide operations.
2) Compare-perform arithmetic and logical comparisons. Some instructions in this
class allow the generation of a trap if the comparison condition is not met.
3) Logical-perform a set of bit-wise Boolean operations.
4) Shift-perform arithmetic and logical shifts, and allow the extraction of 32-bit
words from 64-bit double-words.
2-5
5) Data Movement-perform mqvement of data fields between registers, and the
movement of data to and from external devices and memories.
6) Constant-allow the generation of large constant values in registers.
7) Floating-Point-included for floating-point arithmetic, comparisons, and format
conversions. These instructions are not currently implemented directly in
processor hardware.
8) Branch-perform program jumps and subroutine calls.
9) Miscellaneous-perform miscellaneous control functions and operations not
provided by other classes. 

JMPT Jump True
JMPTI Jump True Indirect
LOAD Load
LOADL Load and Lock
LOADM Load Multiple
LOADSET Load and Set
MFSR Move from Special Register
MFTLB Move from Translation Look-Aside Buffer Register
MTSR Move to Special Register
MTSRIM Move to Special Register Immediate
MTTLB Move to Translation Look-Aside Buffer Register
MUL Multiply Step
MULL Multiply Last Step
MULTIPLY Integer Multiply
MULU Multiply Step, Unsigned
NAND NAND Logical 

source: http://bitsavers.informatik.uni-stuttgart.de/components/amd/Am29000/1987_Am29000_Users_Manual.pdf

11. Kokius adresavimo būdus palaikė kiekviena architektūra?
Kurie režimai buvo panašūs, o kurie skyrėsi?

12. Kokios buvo kiekvienos architektūros I/O galimybės?

13. Ar buvo palaikomi pertraukimai? Kuo pertraukimų mechanizmai buvo
panašūs, kuo jie skyrėsi abiejose architektūrose?

14. Kokius duomenų tipus palaikė kiekviena architektūra aparatūros
lygyje? Ar buvo palaikoma fiksuoto kablelio, slankiojo kablelio
aritmetika? Ar sveikieji skaičiai buvo koduojami kaip ženklas-dydis,
kaip vieneto papildinys (atvirkštinis kodas), dvejeto papildyti
(papildomas kodas)? Kokius kitus „egzotiškus“ duomenų tipus palaikė
architektūra (pvz. dešimtainius skaičius, kompleksinius skaičius ir
kt.)?

15. Kokia buvo kiekvienos sistemos greitaveika? Kokie buvo taktinių
generatorių dažniai, vidutinis/mažiausias/didžiausias ciklų skaičius,
reikalingas kiekvienai komandai įvykdyti, vidutinė sistemos
greitaveika? Kuri sistema buvo našesnė? Koks buv kainos ir našumo
santykis?

16. Ar architektūros naudojo spartinančią atmintį? Jei taip, kokio
dydžio?

17. Kokios buvo tipinės kiekvienos architektūros taikymo sritys? Kaip
šios architektūros buvo naudojamos? Trumpai apibūdinkite (vienoje
pastraipoje) vieną konkretų kiekvienos architektūros panaudojimo
pavyzdį.

18. Kiek programinės įrangos buvo parašyta kiekvienai aptariamai
architektūrai, ar ji (vis dar) prieinama, kur ji buvo naudojama? Kokie
buvo prieinami kompiliatoriai ir programavimo įrankiai (derintojai,
profiliuotojai, surinkėjai)? Kokios programinės įrangos bibliotekos
buvo prieinamos?

19. (neprivaloma) ar yra emuliatorių abiem architektūroms?  Jei tokių
rasite, pateikite jų URL ir (arba) leidinio metaduomenis.
